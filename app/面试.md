####横竖屏切换时Activity的生命周期变化?

######1.没有设置
```java
android:ConfigChanges
```
    onPause->onSaveInstanceState->onStop->onDestory->onCreate->onStart->onRestoreInstanceState()->onResume()
######2.设置
```java
android:configChanges="orientation|keyboardHidden|screenSize">
```
	只会调用onConfigurationChanged方法

####如何保证Service不被杀死？
    - 提供进程优先级，降低进程被杀死的概率
      方法一：监控手机锁屏解锁事件，在屏幕锁屏时启动1个像素的 Activity，在用户解锁时将 Activity 销毁掉。
      方法二：启动前台service。
      方法三：提升service优先级：
      在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = "1000"这个属性设置最高优先级，1000是最高值，如果数字越小则优先级越低，同时适用于广播
    - 在进程被杀死后，进行拉活
      方法一：注册高频率广播接收器，唤起进程。如网络变化，解锁屏幕，开机等
      方法二：双进程相互唤起。
      方法三：依靠系统唤起。
      方法四：onDestroy方法里重启service：service +broadcast 方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service
    - 依靠第三方 根据终端不同，在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推送；其他手机可以考虑接入腾讯信鸽或极光推送与小米推送做 A/B Test

####简述下Acitivty任务栈和使用方法
    任务栈是一种后进先出的结构。位于栈顶的Activity处于焦点状态,当按下back按钮的时候,栈内的Activity会一个一个的出栈,并且调用其onDestory()方法。如果栈内没有Activity,那么系统就会回收这个栈,每个APP默认只有一个栈,以APP的包名来命名

    1. standard：默认模式：每次启动都会创建一个新的activity对象，放到目标任务栈中

    2. singleTop：判断当前的任务栈顶是否存在相同的activity对象，如果存在，则直接使用，如果不存在，那么创建新的activity对象放入栈中

    3. singleTask：在任务栈中会判断是否存在相同的activity，如果存在，那么会清除该activity之上的其他activity对象显示，如果不存在，则会创建一个新的activity放入栈顶

    4. singleIntance：会在一个新的任务栈中创建activity，并且该任务栈种只允许存在一个activity实例，其他调用该activity的组件会直接使用该任务栈种的activity对象

    方法一：
    使用android:launchMode="standard|singleInstance|single Task|singleTop"来控制Acivity任务栈。
    方法二：
    Intent Flags：
    Intent intent=new Intent();
    intent.setClass(MainActivity.this, MainActivity2.class);
    intent.addFlags(Intent. FLAG_ACTIVITY_CLEAR_TOP);
    startActivity(intent);
    Flags有很多，比如：
    Intent.FLAG_ACTIVITY_NEW_TASK   相当于singleTask
    Intent. FLAG_ACTIVITY_CLEAR_TOP   相当于singleTop

####Context相关问题
    Activity和Service以及Application的Context是不一样的,Activity继承自ContextThemeWraper.其他的继承自ContextWrapper.
    每一个Activity和Service以及Application的Context都是一个新的ContextImpl对象
    getApplication()用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法.getApplicationContext()比getApplication()方法的作用域会更广一些，任何一个Context的实例，只要调用getApplicationContext()方法都可以拿到我们的Application对象。
    
    Context的数量等于Activity的个数 + Service的个数 + 1，这个1为Application.
    那Broadcast Receiver，Content Provider呢？Broadcast Receiver，Content Provider并不是Context的子类，他们所持有的Context都是其他地方传过去的，所以并不计入Context总数。

####okHttp 的addInterceptor 和 addNetworkInterceptor 的区别
    - addInterceptor（应用拦截器）:
        1. 不需要担心中间过程的响应,如重定向和重试
        2. 总是只调用一次,即使HTTP响应是从缓存中获取
        3. 观察应用程序的初衷. 不关心OkHttp注入的头信息如: If-None-Match
        4. 允许短路而不调用 Chain.proceed(),即中止调用
        5. 允许重试,使 Chain.proceed()调用多次
    - addNetworkInterceptor（网络拦截器）：
      1. 能够操作中间过程的响应,如重定向和重试
      2. 当网络短路而返回缓存响应时不被调用
      3. 只观察在网络上传输的数据
      4. 携带请求来访问连接

####Fragment生命周期
```java
fragment is added->onAttach()->onCreate()->onCreateView()->onActivityCreated->onStart()->onResume()->fragment is active->onPause->onStop()->onDestoryView()->onDestory()->onDetach()->fragment is destoryed
```
####如何实现Activity窗口快速变暗
```java
 private void dimBackground(final float from, final float to) {
 	final Window window = getWindow();
 	ValueAnimator valueAnimator = ValueAnimator.ofFloat(from, to);
 	valueAnimator.setDuration(500);
 	valueAnimator.addUpdateListener(new AnimatorUpdateListener() {
 		@Override
	 	public void onAnimationUpdate(ValueAnimator animation) {
 			WindowManager.LayoutParams params = window.getAttributes();
 			params.alpha = (Float) animation.getAnimatedValue();
 			window.setAttributes(params);
 		}
 	});
 	valueAnimator.start();
 }
```

####IntentServices
    1. IntentService是Service的子类，是一个异步的，会自动停止的服务，很好解决了传统的Service中处理完耗时操作忘记停止并销毁Service的问题
    2.  生成一个默认的且与线程相互独立的工作线程执行所有发送到onStartCommand()方法的Intent,可以在onHandleIntent()中处理
    3. 串行队列,每次只运行一个任务,不存在线程安全问题,所有任务执行完后自动停止服务,不需要自己手动调用stopSelf()来停止

####内存优化
    - 是有优化过的数据集合 Android提供了一系列优化过后的数据集合工具类，如SparseArray、SparseBooleanArray、LongSparseArray，使用这些API可以让我们的程序更加高效。HashMap工具类会相对比较低效，因为它需要为每一个键值对都提供一个对象入口，而SparseArray就避免掉了基本数据类型转换成对象数据类型的时间
    - 尽量避免使用依赖注入框架 使用依赖注入框架貌似看上去把findViewById()这一类的繁琐操作去掉了，但是这些框架为了要搜寻代码中的注解，通常都需要经历较长的初始化过程，并且将一些你用不到的对象也一并加载到内存中。这些用不到的对象会一直站用着内存空间，可能很久之后才会得到释放，所以可能多敲几行代码是更好的选择
    - 面向对象中封装的思想是不要把类内部的字段暴露给外部，而是提供特定的方法来允许外部操作相应类的内部字段。但在Android中，字段搜寻比方法调用效率高得多，我们直接访问某个字段可能要比通过getters方法来去访问这个字段快3到7倍。但是编写代码还是要按照面向对象思维的，我们应该在能优化的地方进行优化，比如避免在内部调用getters/setters方法。

####事件分发
    - 对于 dispatchTouchEvent，onTouchEvent，return true是终结事件传递。return false 是回溯到父View的onTouchEvent方法
    - ViewGroup 想把自己分发给自己的onTouchEvent，需要拦截器onInterceptTouchEvent方法return true 把事件拦截下来
    - ViewGroup 的拦截器onInterceptTouchEvent 默认是不拦截的，所以return super.onInterceptTouchEvent()=return false
    - View 没有拦截器，为了让View可以把事件分发给自己的onTouchEvent，View的dispatchTouchEvent默认实现（super）就是把事件分发给自己的onTouchEvent

####Binder机制
    1. Client、Server和ServiceManager实现在用户空间中，Binder驱动实现在内核空间中
    2. Binder驱动程序和ServiceManager在Android平台中已经实现，开发者只需要在用户空间实现自己的Client和Server
    3. Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和ServiceManager通过open和ioctl文件操作函数与Binder驱动程序进行通信
    4. Client和Server之间的进程间通信通过Binder驱动程序间接实现
    5. ServiceManager是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力

####Zygote和System进程的启动过程
	Linux Kernel -> init.rc -> app_process
linux内核加载完成后，运行init.rc脚本
    service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server socket zygote stream 666

1. /system/bin/app_process Zygote服务启动的进程名
2. --start-system-server 表明Zygote启动完成之后，要启动System进程。
3. socket zygote stream 666 在Zygote启动时，创建一个权限为666的socket。此socket用来请求Zygote创建新进程。socket的fd保存在名称为“ANDROID_SOCKET_zygote”的环境变

```
app_process ----> (create runtime)ZygoteInit ------> (registerZygoteSocket() runSelectLoopMode()) ------> (startSystemServer() fork) -------> System
```

```
----> (fork())System Process ----> ServerThread
```
####Java内存区域：

- 线程共享内存区
  - Java堆：oom；内存中最大的一块；几乎所有的对象实例和数组都在这类分配内存，Java Heap是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”
  - 方法区：oom；虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
- 线程私有内存区
  - 虚拟机栈：stack；栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构；帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息
  - 本地方法栈：stack；虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务
  - 程序计数器：无；当前线程所执行的字节码的行号指示器；线程私有